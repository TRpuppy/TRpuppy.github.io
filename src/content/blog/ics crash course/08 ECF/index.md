---

title: 'ICS crash course 08 ECF' # (Required, max 60)
description: '大脑.exe未响应' # (Required, 10 to 160)
publishDate: '2025-11-15 00:14:00' # (Required, Date)
tags:
  - ICS Crash Course
heroImage: { src: './fCkHklUc5.jpg', alt: '出错啦！', color: '#B4C6DA' }
draft: false # (set true will only show in development)
language: 'Chinese' # (String as you like)
comment: true # (set false will disable comment, even if you've enabled it in site-config)
---

# ECF(Exception Control Flow)异常控制流

## 异常概述

我们主要处理下面四类异常。其中后三种都属于同步异常，只有Interrupt属于异步异常。

1. 硬件中断(Interrupt)。
   + 这是来自计算机外部硬件设备的信号。比如你按了一下键盘、移动了鼠标、网卡收到了数据、或者硬盘读完了数据。
   + 它跟你程序当前在做什么完全没关系，随时可能发生(**异步发生**)。且是系统正常工作的一部分，不是错误。
   + CPU 会立刻保存当前现场，然后**跳转**到一个预设的**异常处理程序**（比如操作系统里管键盘的代码），处理完这个中断（比如记录下你按了哪个键）之后，再**返回到原来指令的下一条指令**继续执行。
2. 陷阱(Traps)。
   + 这是程序**故意**引发的一个异常。目的就是为了向操作系统请求服务。
   + 正常的程序只能改变程序状态。比如修改寄存器/内存的值等。如果程序想读一个文件，或输出一些信息，或者调用一个新的程序，或者终止当前进程等，就要通过执行`syscall`指令来向**内核**请求服务。服务完成后，再**返回到原来指令的下一条指令**继续执行。
   + 执行`syscall`指令就是一个程序故意设置的到异常处理程序的**陷阱**。和程序中的call很相似，但是能够提高程序权限。
3. 故障(Faults)。
   + 故障是由程序错误引起的。它**有错误修正处理程序**，可能能够被修正。
   + 发生故障时，处理器将控制转移到故障处理程序。如果故障可以修正(例如缺页故障，可以通过操作系统拷贝磁盘内存来修正。)则将控制返回到**引起故障的指令本身**。如果故障不能修正，则终止引起故障的程序。
4. 终止(Aborts)。
   + 终止是指发生了**不可恢复的致命错误**。与故障不同，它没有修正程序，而是直接终止。

## 进程与进程控制(Process and Process control)

> CPU核心的处理器只有一个。那么你是怎么在边看视频的时候后台边跑模型的？
>
> 多个程序是怎么样一起执行的？控制权在哪个程序手上？
>
> 这些问题都是通过进程来解决的。

### 进程


进程的经典定义是一个执行中的过程。操作系统给予进程一种抽象：**使得每个进程拥有一个独立的逻辑控制流，以及一个独立的地址空间。**

![image-20251115124256314](image-20251115124256314.png)

上图是一个运行着三个进程的系统。

从单个进程的角度来看，比如进程A：你会认为它看上去是独占地使用处理器的，只是有时会发生一些停顿。并且你会认为单个进程看上去是独占地使用一块内存地址的，这是因为每个进程都有它自己的私有地址空间，其余的进程不能对这块地址空间进行读写。

但是从系统的角度来看，不同的进程是交错并发执行的。逻辑流在时间上重叠的进程，认为是并发的。例如上图中AB、AC都是并发的，BC不是并发的。

### 内核模式与用户模式

一般而言，进程运行在**用户模式**中。

用户模式中的进程权力很有限，它们不允许进行IO操作，不允许停止处理器，也不允许访问非该进程区域的内存地址。如果它们想要进行这些操作，就需要使用异常控制流来将控制转到**内核模式中的**异常处理程序。

**内核模式**中的进程权力很高。它们可以执行任何指令，并且可以访问系统中的任何内存位置。

除了**通过异常处理程序响应用户模式中的进程**，内核的工作包括**通过上下文切换来调度进程**。

![image-20251115125807319](image-20251115125807319.png)

如上图，上下文切换是为了能够合理地进行进程并发。具体地，它会中断当前进程的控制，先保存当前进程的状态(包括寄存器状态，程序计数器状态，栈状态，程序计数器等等)，然后切换到另一个进程的状态，最后将控制权转移到另外的进程。

### 程序中的进程控制

#### 进程id

每个进程都有自己的进程ID(PID)。进程ID是一个正整数。C语言中，可以使用getpid函数返回该进程的PID，getppid返回父进程的PID。这两个函数在库`<sys/types.h>`中。返回值类型是`pid_t`。

```c++
#include <sys/types.h>
#include <stdio.h>
int main()
{
    printf("getpid = %d\n" , getpid());
    printf("getppid = %d\n" , getppid());
    return 0;
}
```

输出：

```shell
getpid = 2851
getppid = 1492
```

#### fork函数

fork函数不接收参数，返回类型为pid_t。

父进程可以通过fork函数来复制一个子进程。子进程的得到与父进程地址空间相同的一个副本，包括代码，数据，堆，栈，还可以获得父进程所有打开文件的副本。这就意味着**父子进程除了pid不同之外，完全相同。**

fork函数会在父进程和子进程中都进行一次返回。在父进程中，它返回子进程的PID，在子进程中，它返回0。**得到fork函数的返回值是子进程的开始。**

下面是一个实例，来说明fork函数的神奇之处。

```c++
#include <sys/types.h>
#include <stdio.h>
int main()
{
    int x = 1;
    pid_t pid_fork = fork();
    if(pid_fork == 0)
    {
        x ++;
        printf("child : x = %d\n" , x);
    }
    else
    {
        x --;
        printf("parent : x = %d\n" , x);
    }
    printf("pid_fork = %d\n" , pid_fork);
    printf("getpid = %d\n" , getpid());
    printf("getppid = %d\n" , getppid());

    return 0;
}
```

输出：

```shell
parent : x = 0
pid_fork = 2771
getpid = 2770
getppid = 1492
child : x = 2
pid_fork = 0
getpid = 2771
getppid = 2770
```

可以看到，父子两个进程都会被执行一次。在我的操作系统(Ubuntu)上，先执行的是父进程。但是这个顺序在不同的操作系统上都会有差异。**程序员不应该假设进程执行的顺序。**

观察x的信息，可以发现父进程中的x与子进程中的x是**相互独立**的。在父进程中，x虽然+1，但是它不影响子进程中的x。

子进程的PID是2771。这个数字同时出现在了父进程的pid_fork中。

父进程的PID是2770。这个数字同时出现在了子进程的getppid中。

父进程的getppid是1492。这个PID是我打开的终端的进程。

你可以在终端中输入指令`ps`来查看进程信息，输出结果:

```shell
PID TTY       TIME 	   CMD
1492 pts/2    00:00:00 bash
2887 pts/2    00:00:00 ps
```

这个结果的意思是：

第一行：当前终端bash shell的进程ID是1492，运行在2号伪终端上(这是因为我使用的终端是VS code中的终端)，累计使用的CPU时间很短(00:00:00)。

第二行也很有意思：第二行说的是进程ps的信息。ps就是我输入的查看进程信息的指令。它的ID是2887，运行在2号伪终端上，基本没占CPU时间(看个进程信息而已嘛，很快的啦)。

你会发现ps和bash也是父子关系。且bash还有一个儿子——就是我们上面运行的C语言程序(但是在输入ps查看进程信息时，那个进程已经被终结了)。

**思考：fork函数属不属于异常控制流？属于哪一类？**[^1]

**思考：下面的程序输出几个Hello World?**[^2]

```c++
#include <sys/types.h>
#include <stdio.h>
int main()
{
    fork();
    fork();
    printf("Hello World\n");
    return 0;
}
```

[^1]:当然属于。用户模式中的进程没有权限创造一个新的进程，所以创造进程这件事得交给内核进程来干。这是一个标准的**Trap**。
[^2]:四个。别忘了第一个创建出来的子进程也要fork一次。